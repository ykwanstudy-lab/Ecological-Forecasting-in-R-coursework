# 1. Setup: Load packages and check Stan installation
library(cmdstanr)
library(mvgam)
library(dplyr)

# Check if CmdStan is installed and working
# Should return a version number (e.g., "2.32.2")
cmdstan_version()

# 2. Load and Prepare Data
# mvgam requires a 'time' column (integer) and a 'series' column (factor)
pp_data <- read.csv("pp_abundance_timeseries.csv") |>
  mutate(time = newmoonnumber) |>
  mutate(series = as.factor('PP')) |>
  select(time, series, abundance, mintemp, cool_precip)

# Split into training (first 100+ months) and testing (last 24 months) sets
data_train <- filter(pp_data, time <= max(time) - 24)
data_test  <- filter(pp_data, time > max(time) - 24)

# 3. Visualization
# mvgam has built-in plotting for series data
plot_mvgam_series(data = pp_data, y = 'abundance')

# 4. Model 1: Baseline Gaussian AR1
# Fits a linear trend with minimum temperature and an Autoregressive (AR1) process
# Assumes Gaussian errors (often poor for count data)
baseline_model = mvgam(
  abundance ~ mintemp,
  trend_model = AR(p = 1),
  family = gaussian(),
  data = data_train
)

# Diagnostics for Model 1
# Trace plots to check for convergence (MCMC)
mcmc_plot(baseline_model, type = "trace", variable = c("mintemp", "ar1[1]", "sigma[1]"))

# Model summary and residuals
summary(baseline_model)
plot(baseline_model)

# Forecast Model 1
baseline_forecast = forecast(baseline_model, newdata = data_test)
plot(baseline_forecast)

# 5. Model 2: Poisson AR1 (Handling Count Data)
# Uses a Poisson family with a log link to ensure positive integer predictions
poisson_model = mvgam(
  abundance ~ mintemp,
  trend_model = AR(p = 1),
  family = poisson(link = "log"),
  data = data_train
)

# Diagnostics and Forecast for Model 2
summary(poisson_model)
plot(poisson_model)

poisson_forecast = forecast(poisson_model, newdata = data_test)
plot(poisson_forecast)

# Visualize the linear environmental relationship (parametric terms)
plot(poisson_model, type = 'pterms')
plot_predictions(poisson_model, condition = "mintemp")

# 6. Model 3: Poisson GAM AR1 (Non-linear Responses)
# Uses a smooth function s(mintemp) instead of a linear term
poisson_gam_model = mvgam(
  abundance ~ s(mintemp),
  trend_model = AR(p = 1),
  family = poisson(link = "log"),
  data = data_train
)

# Visualize the non-linear smooth
plot(poisson_gam_model, type = 'smooths')
plot(poisson_gam_model, type = "forecast")

plot_predictions(poisson_gam_model, condition = "mintemp")

# Forecast and Diagnostics for Model 3
poisson_gam_forecast = forecast(poisson_gam_model, newdata = data_test)
plot(poisson_gam_forecast)
plot(poisson_gam_model)

# 7. Model 4: State Space Model (Optional)
# Separates observation error from process error
state_space_model = mvgam(
  abundance ~ 1,
  trend_formula = ~ s(mintemp),
  trend_model = AR(p = 1),
  family = poisson(link = "log"),
  data = data_train
)

state_space_forecast = forecast(state_space_model, newdata = data_test)
plot(state_space_forecast)

# 8. Evaluation and Scoring
# Calculate probabilistic scores (CRPS, interval coverage)
scores <- score(poisson_gam_forecast)

# Calculate coverage for a specific interval (e.g., 50%)
scores <- score(poisson_gam_forecast, interval_width = 0.5)
in_interval = scores$PP$in_interval
length(in_interval[in_interval == 1]) / length(in_interval)

# Optional: View the Stan code generated by mvgam
code(poisson_gam_model)

# 1. Calculate scores with a X% interval width
# This checks if observations fall within the middle 80% of the predicted distribution
baseline_scores    <- score(baseline_forecast, interval_width = 0.5)
poisson_scores     <- score(poisson_forecast, interval_width = 0.5)
gam_scores         <- score(poisson_gam_forecast, interval_width = 0.5)
state_space_scores <- score(state_space_forecast, interval_width = 0.5)

# 2. Function to calculate coverage proportion
# (Sum of TRUEs divided by total observations)
calc_coverage <- function(score_object) {
  in_interval <- score_object$PP$in_interval
  sum(in_interval) / length(in_interval)
}

# 3. Extract coverage for each model
baseline_cov    <- calc_coverage(baseline_scores)
poisson_cov     <- calc_coverage(poisson_scores)
gam_cov         <- calc_coverage(gam_scores)
state_space_cov <- calc_coverage(state_space_scores)

# 4. Create Comparison Table
# We compare the calculated coverage against the Target 
coverage_comparison <- data.frame(
  Model = c("Model 1: Gaussian AR1", 
            "Model 2: Poisson AR1", 
            "Model 3: Poisson GAM", 
            "Model 4: State-Space"),
  Target_Coverage = 0.50,
  Actual_Coverage = c(baseline_cov, poisson_cov, gam_cov, state_space_cov)
)

# Calculate the deviation from the target (closer to 0 is better)
coverage_comparison$Deviation <- abs(coverage_comparison$Actual_Coverage - 0.50)

# Print table sorted by best coverage (smallest deviation)
print(coverage_comparison[order(coverage_comparison$Deviation), ])



# 1. Calculate scores for each forecast object
# The score() function from mvgam calculates CRPS for every time step in the test set
baseline_scores    <- score(baseline_forecast)
poisson_scores     <- score(poisson_forecast)
gam_scores         <- score(poisson_gam_forecast)
state_space_scores <- score(state_space_forecast)

# 2. Extract and summarize the CRPS
# We take the mean CRPS across all test time steps to get a single metric for ranking.
# Note: 'PP' is the series name assigned in the data preparation step.

baseline_crps    <- mean(baseline_scores$PP$score, na.rm = TRUE)
poisson_crps     <- mean(poisson_scores$PP$score, na.rm = TRUE)
gam_crps         <- mean(gam_scores$PP$score, na.rm = TRUE)
state_space_crps <- mean(state_space_scores$PP$score, na.rm = TRUE)

# 3. Create a comparison table
model_comparison <- data.frame(
  Model = c("Model 1: Gaussian AR1", 
            "Model 2: Poisson AR1", 
            "Model 3: Poisson GAM", 
            "Model 4: State-Space"),
  Mean_CRPS = c(baseline_crps, poisson_crps, gam_crps, state_space_crps)
)

# 4. Print the table sorted by best performance (Lowest CRPS is best)
print(model_comparison[order(model_comparison$Mean_CRPS), ])

#50% interval
#                  Model    Target_Coverage Actual_Coverage  Deviation
#4  Model 4: State-Space             0.5       0.5416667 0.04166667
#1  Model 1: Gaussian AR1            0.5       0.4583333 0.04166667
#2  Model 2: Poisson AR1             0.5       0.3750000 0.12500000
#3  Model 3: Poisson GAM             0.5       0.6250000 0.12500000

#80% interval
#                  Model    Target_Coverage Actual_Coverage  Deviation
#2  Model 2: Poisson AR1             0.8       0.8333333 0.03333333
#1  Model 1: Gaussian AR1            0.8       0.7083333 0.09166667
#3  Model 3: Poisson GAM             0.8       0.9583333 0.15833333
#4  Model 4: State-Space             0.8       0.9583333 0.15833333

#CRPS
#                  Model Mean_CRPS
#3  Model 3: Poisson GAM  6.974754
#4  Model 4: State-Space  7.909830
#2  Model 2: Poisson AR1 11.568483
#1  Model 1: Gaussian AR1 14.220476
